#!/usr/bin/env node
/**
 * BrikByte Studios — ADR Index Generator (GOV-ADR-TOOLS-001)
 *
 * Responsibilities:
 *  - Scan ADR files (docs/adr/[0-9][0-9][0-9]-*.md)
 *  - Parse YAML front-matter (id, title, status, area, date, etc.)
 *  - Generate docs/adr/000-index.md with:
 *      * A short header
 *      * "By Status" section (table)
 *      * "By Area" section (table)
 *
 * This tool is NON-BLOCKING in v1. It is meant to be run:
 *   - Locally by engineers, or
 *   - In CI as a best-effort step (continue-on-error)
 *
 * Usage:
 *   node scripts/adr/adr-index-generate.js \
 *     --glob "docs/adr/[0-9][0-9][0-9]-*.md" \
 *     --output "docs/adr/000-index.md"
 */

const fs = require("fs");
const path = require("path");
const { globSync } = require("glob");
const yaml = require("yaml");

function parseArgs(argv) {
  const args = {};
  for (let i = 2; i < argv.length; i++) {
    const token = argv[i];
    if (token.startsWith("--")) {
      const key = token.slice(2);
      const next = argv[i + 1];
      if (!next || next.startsWith("--")) {
        args[key] = true;
      } else {
        args[key] = next;
        i++;
      }
    }
  }
  return args;
}

/**
 * Extract YAML front-matter from a Markdown ADR file.
 * See adr-lint.js for details; duplicated here to keep scripts independent.
 */
function extractFrontMatter(raw, filePath) {
  const lines = raw.split(/\r?\n/);

  if (lines[0].trim() !== "---") {
    throw new Error(
      `File "${filePath}" does not start with '---'; ADRs must begin with YAML front-matter.`
    );
  }

  let endIndex = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim() === "---") {
      endIndex = i;
      break;
    }
  }

  if (endIndex === -1) {
    throw new Error(
      `File "${filePath}" has an opening '---' but no closing '---' for YAML front-matter.`
    );
  }

  const frontMatterLines = lines.slice(1, endIndex);
  const frontMatterText = frontMatterLines.join("\n");

  let frontMatter;
  try {
    frontMatter = yaml.parse(frontMatterText) || {};
  } catch (err) {
    throw new Error(
      `YAML parsing error in "${filePath}" front-matter: ${err.message}`
    );
  }

  return frontMatter;
}

/**
 * Build the Markdown for the ADR index.
 *
 * Returns a string representing docs/adr/000-index.md content.
 */
function buildIndexMarkdown(entries) {
  const header = [
    "# Architecture Decision Records — Index",
    "",
    "> Auto-generated by `scripts/adr/adr-index-generate.js`.",
    "> Do not edit this file manually; changes will be overwritten.",
    "",
  ];

  // --- By Status ---
  const byStatus = new Map();
  for (const e of entries) {
    const statusKey = e.status || "Unknown";
    if (!byStatus.has(statusKey)) byStatus.set(statusKey, []);
    byStatus.get(statusKey).push(e);
  }

  const statusSection = ["## By Status", ""];
  if (byStatus.size === 0) {
    statusSection.push("_No ADRs found._", "");
  } else {
    for (const [status, list] of byStatus.entries()) {
      statusSection.push(`### ${status}`, "");
      statusSection.push("| ID | Seq | Title | Date | Areas | File |");
      statusSection.push("| --- | --- | --- | --- | --- | --- |");
      for (const e of list.sort((a, b) => a.seq - b.seq)) {
        const areas = (e.area || []).join(", ");
        statusSection.push(
          `| ${e.id} | ${e.seq} | [${e.title}](${e.relativePath}) | ${e.date || ""} | ${areas} | \`${e.relativePath}\` |`
        );
      }
      statusSection.push("");
    }
  }

  // --- By Area ---
  const byArea = new Map();
  for (const e of entries) {
    const areas = Array.isArray(e.area) && e.area.length > 0 ? e.area : ["(none)"];
    for (const a of areas) {
      if (!byArea.has(a)) byArea.set(a, []);
      byArea.get(a).push(e);
    }
  }

  const areaSection = ["## By Area", ""];
  if (byArea.size === 0) {
    areaSection.push("_No ADRs found._", "");
  } else {
    for (const [area, list] of byArea.entries()) {
      areaSection.push(`### ${area}`, "");
      areaSection.push("| ID | Seq | Title | Status | Date | File |");
      areaSection.push("| --- | --- | --- | --- | --- | --- |");
      for (const e of list.sort((a, b) => a.seq - b.seq)) {
        areaSection.push(
          `| ${e.id} | ${e.seq} | [${e.title}](${e.relativePath}) | ${e.status} | ${e.date || ""} | \`${e.relativePath}\` |`
        );
      }
      areaSection.push("");
    }
  }

  return [...header, ...statusSection, ...areaSection].join("\n");
}

async function main() {
  const args = parseArgs(process.argv);
  const globPattern =
    args.glob || "docs/adr/[0-9][0-9][0-9]-*.md";
  const outputPath = args.output || "docs/adr/000-index.md";

  const files = globSync(globPattern, { nodir: true });

  if (files.length === 0) {
    console.log(
      `ADR index generator: no ADR files found for glob "${globPattern}". Skipping index generation.`
    );
    return;
  }

  const entries = [];

  for (const file of files) {
    const raw = fs.readFileSync(file, "utf-8");
    try {
      const fm = extractFrontMatter(raw, file);
      entries.push({
        id: fm.id || "(missing id)",
        seq: typeof fm.seq === "number" ? fm.seq : 0,
        title: fm.title || "(missing title)",
        status: fm.status || "(missing status)",
        area: fm.area || [],
        date: fm.date || "",
        relativePath: path.relative("docs/adr", file).replace(/\\/g, "/"),
      });
    } catch (err) {
      // Non-blocking: log and continue
      console.warn(
        `ADR index generator: skipping "${file}" due to error: ${err.message}`
      );
      continue;
    }
  }

  const markdown = buildIndexMarkdown(entries);

  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(outputPath, markdown, "utf-8");
  console.log(
    `ADR index generated at "${outputPath}" for ${entries.length} ADR(s).`
  );
}

main().catch((err) => {
  console.warn(
    `ADR index generator encountered an unexpected error (non-blocking): ${err.message}`
  );
  // Intentionally NOT exiting non-zero because this step is best-effort in v1.
});
